#!/usr/bin/env coffee

fs = require 'fs'
esprima = require 'esprima'
compiler = require 'compiler'
{ spawn } = require 'child_process'

argv = process.argv.splice 2

options =
  # our defaults:
  output_filename: null

args =
  "-o": { option: "output_filename", help: "name of the output file." }

files = []
for ai in [0..argv.length-1]
  if args[argv[ai]]?
    o = args[argv[ai]]
    if o.flag?
      options[o.flag] = true
    else if o.option?
      options[o.option] = argv[++ai]
  else
    # end of options signals the rest of the array is files
    files = argv.splice ai
    break

if files.length is 0
    console.warn 'Usage:';
    console.warn '   ejs [options] file1.js file2.js file.js ...'
    process.exit 1

files_remaining = files.length
s_filenames = []

files.forEach (filename) ->
    content = fs.readFileSync filename, 'utf-8'
    parse_tree = esprima.parse content
    compiled_module = compiler.compile parse_tree, filename

    ll_filename = "/tmp/#{filename}.ll"
    bc_filename = "/tmp/#{filename}.bc"
    bc_opt_filename = "/tmp/#{filename}.bc.opt"
    ll_opt_filename = "/tmp/#{filename}.ll.opt"
    s_filename = "/tmp/#{filename}.s"

    llvm_as_args = ["-o=#{bc_filename}", ll_filename]
    opt_args = ["-O3", "-mem2reg", "-o=#{bc_opt_filename}", bc_filename]
    llvm_dis_args = ["-o=#{ll_opt_filename}", bc_opt_filename]
    llc_args = ["-march=x86-64", "-O2", "-o=#{s_filename}", ll_opt_filename]

    compiled_module.writeToFile ll_filename
    llvm_as = spawn "llvm-as", llvm_as_args
    llvm_as.stderr.on "data", (data) -> console.warn "#{data}"
    llvm_as.on "exit", (code) ->
      opt = spawn "opt", opt_args
      opt.stderr.on "data", (data) -> console.warn "#{data}"
      opt.on "exit", (code) ->
        llvm_dis = spawn "llvm-dis", llvm_dis_args
        llvm_dis.stderr.on "data", (data) -> console.warn "#{data}"
        llvm_dis.on "exit", (code) ->
          llc = spawn "llc", llc_args
          llc.stderr.on "data", (data) -> console.warn "#{data}"
          llc.on "exit", (code) ->
            s_filenames.push s_filename
            files_remaining = files_remaining - 1
            if files_remaining is 0
              map_filename = generate_require_map()

              clang_args = ["-o", options.output_filename || "#{files[0]}.exe"].concat s_filenames
              clang_args.push map_filename
              clang_args.push "../runtime/libecho.a"

              clang = spawn "clang", clang_args
              clang.stderr.on "data", (data) -> console.warn "#{data}"
              clang.on "exit", (code) ->
                console.warn "done."

generate_require_map = ->
  sanitize = (filename, c_callable) ->
    filename = filename.replace /\.js$/, ""
    if c_callable
      filename = filename.replace /[.,-\/\\]/, "_" # this is insanely inadequate
    filename
  map_path = "/tmp/#{files[0]}-require-map.c"
  map = fs.createWriteStream map_path
  map.write "typedef struct _EJSValue EJSValue;\n"
  map.write "typedef EJSValue* (*ToplevelFunc) (EJSValue *env, EJSValue *this, int argc, EJSValue *exports);\n"
  map.write "typedef struct { const char* name;  ToplevelFunc func;  EJSValue *cached_exports; } EJSRequire;\n"
  files.forEach (filename) ->
    sanitized = sanitize filename, true
    map.write "extern EJSValue* _ejs_toplevel_#{sanitized} (EJSValue* env, EJSValue *this, int argc, EJSValue *exports);\n"

  map.write "EJSRequire _ejs_require_map[] = {\n"
  files.forEach (filename) ->
    map.write "  { \"#{sanitize filename, false}\", _ejs_toplevel_#{sanitize filename, true}, 0 },\n"
  map.write "  { 0, 0, 0 }\n"
  map.write "};\n"
  map.write "const char *entry_filename = \"#{sanitize files[0], false}\";\n";
  map.end()
  map_path

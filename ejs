#!/usr/bin/env coffee

path = require 'path'
fs = require 'fs'
util = require 'echo-util'
{ spawn } = require 'child_process'
debug = require 'debug'
        
# if we're running under coffee/node, argv will be ["coffee", ".../ejs", ...]
# if we're running the compiled ejs.exe, argv will be [".../ejs.js.exe", ...]
slice_count = if __ejs? then 1 else 2
argv = process.argv.slice slice_count

files = []
temp_files = []

options =
        # our defaults:
        debug_level: 0
        output_filename: null
        combine_scripts: false
        show_help: false
        leave_temp_files: false
        target: "osx"
        external_modules: []
        extra_clang_args: ""
        ios_sdk: "5.0"
        ios_min: "5.0"
        basename: false

add_external_module = (modinfo) ->
        [library,module_name,module_entrypoint,link_flags] = modinfo.split ','
        options.external_modules.push { library, module_name, module_entrypoint, link_flags }

set_target = (targetinfo) ->
        switch targetinfo
          when "osx" then options.target = "osx"
          when "sim" then options.target = "sim"
          when "dev" then options.target = "dev"
          else
                throw "invalid target specification `#{targetinfo}'."

set_extra_clang_args = (arginfo) ->
        options.extra_clang_args = arginfo

increase_debug_level = ->
        options.debug_level += 1
        
args =
        "-d":
                handler: increase_debug_level
                handlerArgc: 0
                help:    "debug output.  more instances of this flag increase the amount of spew."
        "-s":
                flag:    "combine_scripts"
                help:    "treat all toplevels as being 1 context, evaluating them in the order present on the command line"
        "-o":
                option:  "output_filename"
                help:    "name of the output file."
        "--basename":
                flag:    "basename"
                help:    "strip paths off .js files so you can require them using just the filename"
        "--leave-temp":
                flag:    "leave_temp_files"
                help:    "leave temporary files in /tmp from compilation"
        "--module":
                handler: add_external_module
                handlerArgc: 1
                help:    "--module library.a,module-name,module_init,link_flags"
        "--help":
                flag:    "show_help",
                help:    "output this help info."
        "--target":
                handler: set_target
                handlerArgc: 1
                help:    "--target osx|sim|dev"
        "--extra-clang-args":
                handler: set_extra_clang_args
                handlerArgc: 1
                help:    "extra arguments to pass to the clang command (used to compile the .s to .o)"
        "--ios-sdk":
                option:  "ios_sdk"
                help:    "the version of the ios sdk to use.  useful if more than one is installed.  Default is 5.0."
        "--ios-min":
                option:  "ios_min"
                help:    "the minimum version of ios to support.  Default is 5.0."

output_usage = ->
        console.warn 'Usage:';
        console.warn '   ejs [options] file1.js file2.js file.js ...'
        
output_options = ->
        console.warn 'Options:'
        for a of args
                console.warn "   #{a}:  #{args[a].help}"

if argv.length > 0
        skipNext = 0
        for ai in [0..argv.length-1]
                if skipNext > 0
                        skipNext -= 1
                else
                        if args[argv[ai]]?
                                o = args[argv[ai]]
                                if o.flag?
                                        options[o.flag] = true
                                else if o.option?
                                        options[o.option] = argv[++ai]
                                        skipNext = 1
                                else if o.handler?
                                        handler_args = []
                                        handler_args.push argv[++ai] for i in [0...o.handlerArgc]
                                        o.handler.apply null, handler_args
                                        skipNext = o.handlerArgc
                        else
                                # end of options signals the rest of the array is files
                                files = argv.slice ai
                                break

if options.show_help
        output_usage()
        console.warn ''
        output_options()
        process.exit 0
        
if files.length is 0
        output_usage()
        process.exit 0

debug.setLevel options.debug_level

files_remaining = 0

o_filenames = []

base_filenames = (path.basename file for file in files)

compiled_modules = []

esprima = require 'esprima'
compiler = require 'compiler'

sim_base="/Developer/Platforms/iPhoneSimulator.platform"
dev_base="/Developer/Platforms/iPhoneOS.platform"

sim_bin="#{sim_base}/Developer/usr/bin"
dev_bin="#{dev_base}/Developer/usr/bin"

target_llc_args =
        osx: ["-march=x86-64"]
        sim: ["-march=x86"]
        dev: ["-march=arm"]

target_linker =
        osx: "clang++"
        sim: "#{sim_bin}/clang++"
        dev: "#{dev_bin}/clang++"
        
target_link_args =
        osx: [ ]
        sim: [ "-isysroot", "#{sim_base}/Developer/SDKs/iPhoneSimulator#{options.ios_sdk}.sdk", "-arch", "i386", "-miphoneos-version-min=#{options.ios_min}" ]
        dev: [ "-isysroot", "#{dev_base}/Developer/SDKs/iPhoneOS#{options.ios_sdk}.sdk", "-arch", "armv7", "-miphoneos-version-min=#{options.ios_min}" ]

target_libraries =
        osx: [ "-framework", "Foundation", "-framework", "AppKit" ]
        sim: [ "-framework", "Foundation", "-framework", "UIKit", "-framework", "GLKit", "-framework", "OpenGLES", "-framework", "CoreGraphics" ]
        dev: [ "-framework", "Foundation", "-framework", "UIKit" ]

target_libecho =
        osx: "runtime/libecho.a"
        sim: "runtime/libecho.a.ios"
        dev: "runtime/libecho.a.ios"

extra_libs =
        osx: "external-deps/pcre-osx/.libs/libpcre16.a"
        sim: "external-deps/pcre-iossim/.libs/libpcre16.a"
        dev: "external-deps/pcre-iosdev/.libs/libpcre16.a"

target_path_prepend =
        osx: ""
        sim: "#{sim_bin}"
        dev: "#{dev_bin}"

compileFile = (filename, content, compileCallback) ->
        try
                parse_tree = esprima.parse content, loc: (if __ejs? then false else true), raw: true
        catch e
                console.warn "parse error at #{e}:"
                process.exit -1

        base_filename = util.genFreshFileName path.basename filename
        compiled_module = compiler.compile parse_tree, base_filename, filename

        ll_filename = "/tmp/#{base_filename}.ll"
        bc_filename = "/tmp/#{base_filename}.bc"
        ll_opt_filename = "/tmp/#{base_filename}.ll.opt"
        o_filename = "/tmp/#{base_filename}.o"

        temp_files.push ll_filename, bc_filename, ll_opt_filename, o_filename
        
        llvm_as_args = ["-o=#{bc_filename}", ll_filename]
        opt_args = ["-O3", "-early-cse", "-mem2reg", "-adce", "-strip-dead-prototypes", "-instsimplify", "-S", "-o=#{ll_opt_filename}", bc_filename]
        llc_args = target_llc_args[options.target].concat ["-O2", "-filetype=obj", "-o=#{o_filename}", ll_opt_filename]

        compiled_module.writeToFile ll_filename

        compiled_modules.push filename: (if options.basename then path.basename(filename) else filename), module_toplevel: compiled_module.toplevel_name

        if __ejs?
                # in ejs spawn is synchronous.
                spawn "llvm-as", llvm_as_args
                spawn "opt", opt_args
                spawn "llc", llc_args
                o_filenames.push o_filename
                compileCallback()
        else
                debug.log 1, "executing `llvm-as #{llvm_as_args.join ' '}'"
                llvm_as = spawn "llvm-as", llvm_as_args
                llvm_as.stderr.on "data", (data) -> console.warn "#{data}"
                llvm_as.on "exit", (code) ->
                        debug.log 1, "executing `opt #{opt_args.join ' '}'"
                        opt = spawn "opt", opt_args
                        opt.stderr.on "data", (data) -> console.warn "#{data}"
                        opt.on "exit", (code) ->
                                debug.log 1, "executing `llc #{llc_args.join ' '}'"
                                llc = spawn "llc", llc_args
                                llc.stderr.on "data", (data) -> console.warn "#{data}"
                                llc.on "exit", (code) ->
                                        o_filenames.push o_filename
                                        compileCallback()

relative_to_ejs_exe = (n) ->
        path.resolve (path.dirname process.argv[if __ejs? then 0 else 1]), n
                

generate_require_map = ->
        sanitize = (filename, c_callable) ->
                filename = filename.replace /\.js$/, ""
                if c_callable
                        filename = filename.replace /[.,-\/\\]/g, "_" # this is insanely inadequate
                filename
        map_path = "/tmp/#{util.genFreshFileName path.basename files[0]}-require-map.cpp"
        map = fs.createWriteStream map_path
        map.write "#include \"#{relative_to_ejs_exe 'runtime/ejs.h'}\"\n"
        map.write "extern \"C\" {\n"
        map.write "typedef ejsval (*ExternalModuleEntry) (ejsval exports);\n"
        map.write "typedef struct { const char* name;  ExternalModuleEntry func;  ejsval cached_exports; } EJSExternalModuleRequire;\n"
        map.write "typedef ejsval (*ToplevelFunc) (ejsval env, ejsval _this, int argc, ejsval *args);\n"
        map.write "typedef struct { const char* name;  ToplevelFunc func;  ejsval cached_exports; } EJSRequire;\n"
        options.external_modules.forEach ({ module_entrypoint }) ->
                map.write "extern ejsval #{module_entrypoint} (ejsval exports);\n"

        compiled_modules.forEach ({ filename, module_toplevel }) ->
                sanitized = sanitize filename, true
                map.write "extern ejsval #{module_toplevel} (ejsval env, ejsval _this, int argc, ejsval *args);\n"

        map.write "EJSRequire _ejs_require_map[] = {\n"
        compiled_modules.forEach ({ filename, module_toplevel }) ->
                map.write "  { \"#{sanitize filename, false}\", #{module_toplevel}, 0 },\n"
        map.write "  { 0, 0, 0 }\n"
        map.write "};\n"

        map.write "EJSExternalModuleRequire _ejs_external_module_require_map[] = {\n"
        options.external_modules.forEach ({ module_name, module_entrypoint }) ->
                map.write "  { \"#{module_name}\", #{module_entrypoint}, 0 },\n"
        map.write "  { 0, 0, 0 }\n"
        map.write "};\n"
        
        map.write "const char *entry_filename = \"#{sanitize base_filenames[0], false}\";\n";

        map.write "};"
        map.end()

        temp_files.push map_path
        
        map_path


do_final_link = ->
        map_filename = generate_require_map compiled_modules

        if __ejs?
                console.warn "ejs doesn't have process.env yet."
        else
                process.env.PATH = "#{target_path_prepend[options.target]}:#{process.env.PATH}"

        clang_args = target_link_args[options.target].concat ["-o", options.output_filename || "#{files[0]}.exe"].concat o_filenames
        
        clang_args.push map_filename
        
        clang_args.push relative_to_ejs_exe target_libecho[options.target]
        clang_args.push relative_to_ejs_exe extra_libs[options.target]
        
        options.external_modules.forEach (extern_module) ->
                clang_args.push extern_module.library
                clang_args = clang_args.concat extern_module.link_flags.split " "

        clang_args = clang_args.concat target_libraries[options.target]

        debug.log 1, "executing `#{target_linker[options.target]} #{clang_args.join ' '}'"
        
        if __ejs?
                spawn target_linker[options.target], clang_args
                # we ignore leave_tmp_files here
                console.warn "done."
        else
                clang = spawn target_linker[options.target], clang_args
                clang.stderr.on "data", (data) -> console.warn "#{data}"
                clang.on "exit", (code) ->
                        if not options.leave_temp_files
                                cleanup ->
                                        console.warn "done."

cleanup = (done) ->
        files_to_delete = temp_files.length
        temp_files.forEach (filename) ->
                fs.unlink filename, (err) ->
                        files_to_delete = files_to_delete - 1
                        done() if files_to_delete is 0
                
file_compiled = ->
        files_remaining = files_remaining - 1
        do_final_link() if files_remaining is 0

if options.combine_scripts
        script_content = ""
        files.forEach (filename) ->
                script_content = script_content + fs.readFileSync filename, 'utf-8'
        files_remaining = 1
        compileFile files[0], script_content, file_compiled
else
        files_remaining = files.length
        files.forEach (filename) ->
                compileFile filename, (fs.readFileSync filename, 'utf-8'), file_compiled

# Local Variables:
# mode: coffee
# End:

#!/usr/bin/env coffee

path = require 'path'
fs = require 'fs'
util = require 'echo-util'
{ spawn } = require 'child_process'
        
# if we're running under coffee/node, argv will be ["coffee", ".../ejs", ...]
# if we're running the compiled ejs.exe, argv will be [".../ejs.js.exe", ...]
slice_count = if __ejs? then 1 else 2
argv = process.argv.slice slice_count

external_modules = []
files = []
temp_files = []

add_external_module = (modinfo) ->
        [library,module_name,module_entrypoint,link_flags] = modinfo.split ','
        external_modules.push { library, module_name, module_entrypoint, link_flags }

options =
        # our defaults:
        output_filename: null
        combine_scripts: false
        show_help: false
        leave_temp_files: false

args =
        "-s":
                flag:    "combine_scripts"
                help:    "treat all toplevels as being 1 context, evaluating them in the order present on the command line"
        "-o":
                option:  "output_filename"
                help:    "name of the output file."
        "--leave-temp":
                flag:    "leave_temp_files"
                help:    "leave temporary files in /tmp from compilation"
        "--module":
                handler: add_external_module
                help:    "--module library.a,module-name,module_init,link_flags"
        "--help":
                flag:    "show_help",
                help:    "output this help info."

output_usage = ->
        console.warn 'Usage:';
        console.warn '   ejs [options] file1.js file2.js file.js ...'
        
output_options = ->
        console.warn 'Options:'
        for a of args
                console.warn "   #{a}:  #{args[a].help}"

if argv.length > 0
        skipNext = false
        for ai in [0..argv.length-1]
                if skipNext
                        skipNext = false
                else
                        if args[argv[ai]]?
                                o = args[argv[ai]]
                                if o.flag?
                                        options[o.flag] = true
                                else if o.option?
                                        options[o.option] = argv[++ai]
                                        skipNext = true
                                else if o.handler?
                                        o.handler argv[++ai]
                                        skipNext = true
                        else
                                # end of options signals the rest of the array is files
                                files = argv.slice ai
                                break

if options.show_help
        output_usage()
        console.warn ''
        output_options()
        process.exit 0
        
if files.length is 0
        output_usage()
        process.exit 0

files_remaining = 0

o_filenames = []

base_filenames = (path.basename file for file in files)

compiled_modules = []

esprima = require 'esprima'
compiler = require 'compiler'

compileFile = (filename, content, compileCallback) ->
        try
                parse_tree = esprima.parse content, loc: true, raw: true
        catch e
                console.warn "parse error at #{filename}:"
                process.exit -1

        base_filename = util.genFreshFileName path.basename filename
        compiled_module = compiler.compile parse_tree, base_filename, filename

        ll_filename = "/tmp/#{base_filename}.ll"
        bc_filename = "/tmp/#{base_filename}.bc"
        ll_opt_filename = "/tmp/#{base_filename}.ll.opt"
        s_filename = "/tmp/#{base_filename}.s"
        o_filename = "/tmp/#{base_filename}.o"

        temp_files.push ll_filename, bc_filename, ll_opt_filename, s_filename, o_filename
        
        llvm_as_args = ["-o=#{bc_filename}", ll_filename]
        opt_args = ["-O3", "-early-cse", "-mem2reg", "-adce", "-strip-dead-prototypes", "-instsimplify", "-S", "-o=#{ll_opt_filename}", bc_filename]
        llc_args = ["-march=x86-64", "-O2", "-o=#{s_filename}", ll_opt_filename]
        clang_args = ["-march=x86-64", "-O2", "-c", "-o", o_filename, s_filename]

        compiled_module.writeToFile ll_filename

        compiled_modules.push filename: filename, module_toplevel: compiled_module.toplevel_name

        if __ejs?
                # in ejs spawn is synchronous.
                spawn "llvm-as", llvm_as_args
                spawn "opt", opt_args
                spawn "llc", llc_args
                spawn "clang", clang_args
                o_filenames.push o_filename
                compileCallback()
        else
                llvm_as = spawn "llvm-as", llvm_as_args
                llvm_as.stderr.on "data", (data) -> console.warn "#{data}"
                llvm_as.on "exit", (code) ->
                        opt = spawn "opt", opt_args
                        opt.stderr.on "data", (data) -> console.warn "#{data}"
                        opt.on "exit", (code) ->
                                llc = spawn "llc", llc_args
                                llc.stderr.on "data", (data) -> console.warn "#{data}"
                                llc.on "exit", (code) ->
                                        clang = spawn "clang", clang_args
                                        clang.stderr.on "data", (data) -> console.warn "#{data}"
                                        clang.on "exit", (code) ->
                                                o_filenames.push o_filename
                                                compileCallback()

generate_require_map = ->
        sanitize = (filename, c_callable) ->
                if __ejs?
                        filename = filename.replace ".js", ""
                        if c_callable
                                filename = filename.replace ".", "_"
                                filename = filename.replace ",", "_"
                                filename = filename.replace "-", "_"
                                filename = filename.replace "/", "_"
                                filename = filename.replace "\\", "_"
                        filename
                else                                
                        filename = filename.replace /\.js$/, ""
                        if c_callable
                                filename = filename.replace /[.,-\/\\]/g, "_" # this is insanely inadequate
                        filename
        map_path = "/tmp/#{util.genFreshFileName path.basename files[0]}-require-map.cpp"
        map = fs.createWriteStream map_path
        map.write "extern \"C\" {"
        map.write "typedef struct _EJSValue EJSValue;\n"
        map.write "typedef int EJSBool;\n"
        map.write "typedef EJSValue* (*ExternalModuleEntry) (EJSValue *exports);\n"
        map.write "typedef struct { const char* name;  ExternalModuleEntry func;  EJSValue *cached_exports; } EJSExternalModuleRequire;\n"
        map.write "typedef EJSValue* (*ToplevelFunc) (EJSValue *env, EJSValue *_this, int argc, EJSValue **args);\n"
        map.write "typedef struct { const char* name;  ToplevelFunc func;  EJSValue *cached_exports; } EJSRequire;\n"
        external_modules.forEach ({ module_entrypoint }) ->
                map.write "extern EJSValue* #{module_entrypoint} (EJSValue *exports);\n"

        compiled_modules.forEach ({ filename, module_toplevel }) ->
                sanitized = sanitize filename, true
                map.write "extern EJSValue* #{module_toplevel} (EJSValue* env, EJSValue *_this, int argc, EJSValue **args);\n"

        map.write "EJSRequire _ejs_require_map[] = {\n"
        compiled_modules.forEach ({ filename, module_toplevel }) ->
                map.write "  { \"#{sanitize (path.basename filename), false}\", #{module_toplevel}, 0 },\n"
        map.write "  { 0, 0, 0 }\n"
        map.write "};\n"

        map.write "EJSExternalModuleRequire _ejs_external_module_require_map[] = {\n"
        external_modules.forEach ({ module_name, module_entrypoint }) ->
                map.write "  { \"#{module_name}\", #{module_entrypoint}, 0 },\n"
        map.write "  { 0, 0, 0 }\n"
        map.write "};\n"
        
        map.write "const char *entry_filename = \"#{sanitize base_filenames[0], false}\";\n";

        map.write "};"
        map.end()

        temp_files.push map_path
        
        map_path


do_final_link = ->
        map_filename = generate_require_map compiled_modules

        clang_args = ["-o", options.output_filename || "#{files[0]}.exe"].concat o_filenames
        clang_args.push map_filename
        clang_args.push path.resolve (path.dirname process.argv[if __ejs? then 0 else 1]), "runtime/libecho.a"
        external_modules.forEach (extern_module) ->
                clang_args.push extern_module.library
                clang_args = clang_args.concat extern_module.link_flags.split " "

        if __ejs?
                spawn "clang++", clang_args
                # we ignore leave_tmp_files here
                console.warn "done."
        else
                clang = spawn "clang++", clang_args
                clang.stderr.on "data", (data) -> console.warn "#{data}"
                clang.on "exit", (code) ->
                        if not options.leave_temp_files
                                cleanup ->
                                        console.warn "done."

cleanup = (done) ->
        files_to_delete = temp_files.length
        temp_files.forEach (filename) ->
                fs.unlink filename, (err) ->
                        files_to_delete = files_to_delete - 1
                        done() if files_to_delete is 0
                
file_compiled = ->
        files_remaining = files_remaining - 1
        do_final_link() if files_remaining is 0

if options.combine_scripts
        script_content = ""
        files.forEach (filename) ->
                script_content = script_content + fs.readFileSync filename, 'utf-8'
        files_remaining = 1
        compileFile files[0], script_content, file_compiled
else
        files_remaining = files.length
        files.forEach (filename) ->
                compileFile filename, (fs.readFileSync filename, 'utf-8'), file_compiled

# Local Variables:
# mode: coffee
# End:
